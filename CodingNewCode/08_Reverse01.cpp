/*************************************************************************
[编程题] 01翻转
时间限制：1秒
空间限制：32768K
牛牛正在挑战一款名为01翻转的游戏。游戏初始有A个0,B个1，牛牛的目标就是把所有的值都变为1，
每次操作牛牛可以任意选择恰好K个数字，并将这K个数字的值进行翻转(0变为1，1变为0)。牛牛如果
使用最少的操作次数完成这个游戏就可以获得奖品，牛牛想知道最少的操作次数是多少？

例如:A = 4 B = 0 K = 3 
0000 -> 1110 -> 1001 -> 0100 -> 1111 
需要的最少操作次数为4 
输入描述:
输入为一行：
一共三个整数A(0 ≤ A ≤ 100,000),B(0 ≤ B ≤ 100,000),K(1 ≤ K ≤100,000).以空格分隔


输出描述:
输出一个整数，表示最少需要的操作次数。如果不能完成，则输出-1


算法思想：首先很明显的是，因为最终结果为全是1，那么0翻转的次数一定是奇数次，1翻转的次数
一定是偶数次，而且翻转的总次数之和等于操作次数和k的乘积；假设翻转的次数为L,因为有A个0，
那么至少会翻转A次，那么剩下的翻转次数K*L-A一定是偶数,同时0剩下的最大翻转次数一定是小于L
的偶数，1剩下的最大翻转次数一定不大于L，那么其实会产生一个不等式即：K*L-A<=A*((L-1)/2*2)+B*(L/2*2)，
此处L/2*2是保证翻转次数为偶数次
************************************************************************/

#include <iostream>

using namespace std;

int main(void) 
{
    int K,A,B, MAX = 200000;

    while(cin>>A>>B>>K) {
        int N;
        for (N = 0; N < MAX; N++) 
        {
            if ((N*K - A) < 0 || ((N*K - A) & 0x1) != 0) 
                continue;
            if ((N*K - A)/2 <= A*((N-1)/2) + B*(N/2) || A == 0) 
                break;
        }
        if (N < MAX) 
            cout<<N<<endl;
        else
            cout<<-1<<endl;
    }
    return 0;
}