/***********************************************
[编程题] 暗黑的字符串
时间限制：1秒
空间限制：32768K
一个只包含'A'、'B'和'C'的字符串，如果存在某一段长度为3的连续子串中恰好'A'、'B'和'C'各有一个，
那么这个字符串就是纯净的，否则这个字符串就是暗黑的。
例如：
BAACAACCBAAA 连续子串"CBA"中包含了'A','B','C'各一个，所以是纯净的字符串
AABBCCAABB 不存在一个长度为3的连续子串包含'A','B','C',所以是暗黑的字符串
你的任务就是计算出长度为n的字符串(只包含'A'、'B'和'C')，有多少个是暗黑的字符串。 
输入描述:
输入一个整数n，表示字符串长度(1 ≤ n ≤ 30)


输出描述:
输出一个整数表示有多少个暗黑字符串

算法思想：动态规划的题目
我们可以将状态分为两种：一种是字符串的最后两个字符相同（用S(n)表示），另一种是最后两个字符不同（用D(n)表示）。
这样划分使状态转移更加抽象，但好处是状态转移方程更加精简，处理起来更加方便。

0. f(n-1) = S(n-1) + D(n-1)
1. 如果相同（假设有S(n-1)个），那么新增加的ABC都可以，有3*S(n-1)种
2. 如果不相同（假设有D(n-1)个），那么新增加的字母只能是那两个字母中的一个，比如AB只能扩展为ABA和ABB，有2*D(n-1)种

那么可以得出f(n) = 3*S(n-1) + 2*D(n-1) = 2*f(n-1) + S(n-1)
此时发现多了一个S(n-1)项无法消除，因为S(n-1)是f(n-1)的一个子集，我们自然需要去更前面的状态，比如f(n-2)中去寻找
S(n-1)和f(n-2)的关系。

此时再观察上文的两个情况分析：
1. 如果相同（假设有S(n-1)个），那么新增加的ABC都可以，有3*S(n-1)种
    ---这其中，扩展之后的结果中，有1/3的结果是相同的，个数就是S(n-1)，比如AA分别变为AAA，AAB，AAC，而不同的有2*S(n-1）
2. 如果不相同（假设有D(n-1)个），那么新增加的字母只能是那两个字母中的一个，比如AB只能扩展为ABA和ABB，有2*D(n-1)种
    ---这其中，扩展之后的结果中，有1/2的结果是相同的，个数就是D(n-1)，比如AB分别变为ABA，ABB，不相同的也是D(n-1)

结合1、2分析可知：S(n)=S(n-1)+D(n-1)；D(n)=2*S(n-1)+D(n-1)
可得S(n) = f(n-1)

总是所述：f(n) = 2*f(n-1) + f(n-2)
***********************************************/

#include <iostream>

using namespace std;

long long getBlackStringNum(int n)
{
    if(n == 1)
        return 3;
    else if(n == 2)
        return 9;
    long long fn, fa = 9, fb = 3;
    for(int i = 3; i <= n; ++i)
    {
        fn = 2*fa + fb;
        fb = fa;
        fa = fn;
    }
    return fn;
}

int main(void)
{
    int n;
    cin >> n;

    cout << getBlackStringNum(n) << endl;

    return 0;
}